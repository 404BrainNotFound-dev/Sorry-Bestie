<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>MODI PAGLU</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0;touch-action:manipulation}
  html,body{height:100%}
  body{
    display:flex;align-items:center;justify-content:center;
    background:linear-gradient(to bottom,#64b3f4,#c2e59c);
    font-family:'Segoe UI', 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
    -webkit-tap-highlight-color:transparent;
    overscroll-behavior: none;
  }
  #game-container{
    position:relative;width:100%;height:100vh;max-width:360px;max-height:640px;
    border-radius:16px;overflow:hidden;
    box-shadow:0 12px 30px rgba(0,0,0,.25);
    -webkit-user-select:none;user-select:none;
    touch-action: none;
    background:#f8f9fa;
  }
  #game-canvas{position:absolute;left:0;top:0;width:100%;height:100%}
  .screen{
    position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;
    justify-content:center;background:rgba(255,255,255,0.88);z-index:10;
    backdrop-filter:blur(10px);
  }
  .screen.hidden{display:none}
  h1{font-size:7vw;font-weight:800;color:#2c3e50;margin-bottom:8px;text-shadow:none}
  h2{font-size:5.5vw;font-weight:700;color:#e74c3c;margin-bottom:12px}
  .score-display{font-size:4.8vw;font-weight:700;color:#2c3e50}
  .highscore-display{font-size:3.2vw;color:#f39c12;margin-bottom:16px;font-weight:600}
  .btn{
    background:linear-gradient(135deg,#3498db,#2980b9);border:none;border-radius:32px;
    padding:14px 32px;font-weight:700;color:white;cursor:pointer;margin:10px 0;
    box-shadow:0 4px 12px rgba(52,152,219,0.3);font-size:4.5vw;min-width:180px;
    transition:all 0.2s ease;touch-action: manipulation;
  }
  .btn:active{transform:scale(0.96);box-shadow:0 2px 8px rgba(52,152,219,0.4)}
  #score{position:absolute;top:2vh;left:0;width:100%;text-align:center;
    font-size:9vw;font-weight:800;color:#2c3e50;z-index:5;display:none;
    text-shadow:0 2px 4px rgba(0,0,0,0.1)}
  .sound-btn{
    position:absolute;top:2vh;right:3vw;background:rgba(255,255,255,0.9);
    border-radius:50%;width:10vw;height:10vw;border:none;z-index:20;
    box-shadow:0 2px 8px rgba(0,0,0,0.2);font-size:4vw;
  }
  #modi-image{position:absolute;z-index:15;left:0;top:0;width:100%;height:100%;display:none}
  .leaderboard-item{
    display:flex;justify-content:space-between;width:85%;max-width:280px;
    padding:10px 0;border-bottom:1px solid rgba(44,62,80,0.15);
    font-size:4vw;color:#2c3e50;
  }
  #loading-text{font-size:4.8vw;color:#2c3e50;font-weight:700;text-align:center;
    margin-bottom:25px;text-shadow:none}
  #loading-bird{width:14vw;height:14vw;animation:float 3s ease-in-out infinite}
  @keyframes float {
    0%, 100% { transform: translateY(0) rotate(0deg); }
    50% { transform: translateY(-8vw) rotate(5deg); }
  }
  .loading-container{
    background:rgba(255,255,255,0.95);border-radius:16px;padding:25px;
    text-align:center;max-width:85vw;box-shadow:0 8px 20px rgba(0,0,0,0.15)
  }
  .loading-title{font-size:5.2vw;font-weight:800;color:#2980b9;margin-bottom:20px}
  .loading-bar-container{
    width:75vw;height:12px;background:#ecf0f1;border-radius:6px;
    overflow:hidden;position:relative;margin:20px 0;box-shadow:inset 0 1px 2px rgba(0,0,0,0.1)
  }
  .loading-bar{
    height:100%;width:0%;background:linear-gradient(90deg,#3498db,#2ecc71);
    border-radius:6px;transition:width 0.1s linear
  }
  .loading-bird-end{
    position:absolute;top:-6px;width:8vw;height:8vw;transition:transform 8s linear
  }
</style>
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas"></canvas>
    <div id="score">0</div>
    <button id="sound-btn" class="sound-btn">ðŸ”Š</button>
    <img id="modi-image" src="modi.jpg" alt="Game Over">

    <div id="loading-screen" class="screen">
      <div class="loading-container">
        <div id="loading-text">Help Modi secure votes</div>
        <img id="loading-bird" src="head.png" alt="Loading">
      </div>
    </div>

    <div id="pre-game-loading-screen" class="screen hidden">
      <div class="loading-container">
        <div class="loading-title">VOTE COUNTING IN PROGRESS</div>
        <div class="loading-bar-container">
          <div id="loading-bar" class="loading-bar"></div>
          <img id="loading-bird-end" class="loading-bird-end" src="head.png" alt="Loading End">
        </div>
      </div>
    </div>

    <div id="start-screen" class="screen hidden">
      <h1>MODI HEIST</h1>
      <button id="play-btn" class="btn">PLAY GAME</button>
      <button id="leaderboard-btn" class="btn">LEADERBOARD</button>
      <button id="exit-btn" class="btn">EXIT</button>
    </div>

    <div id="leaderboard-screen" class="screen hidden">
      <h2>LEADERBOARD</h2>
      <div class="leaderboard-item">
        <span>Usman</span>
        <span>69ðŸ‘€</span>
      </div>
      <div class="leaderboard-item">
        <span>You</span>
        <span id="player-highscore">0</span>
      </div>
      <button id="back-btn" class="btn">BACK</button>
    </div>

    <div id="difficulty-screen" class="screen hidden">
      <h2>SELECT MODE</h2>
      <button id="easy-btn" class="btn">EASY MODE</button>
      <button id="back-difficulty-btn" class="btn">BACK</button>
    </div>

    <div id="game-over-screen" class="screen hidden">
      <h2>GAME OVER</h2>
      <div class="score-display">Score: <span id="final-score">0</span></div>
      <div class="highscore-display">High Score: <span id="final-highscore">0</span></div>
      <button id="restart-btn" class="btn">PLAY AGAIN</button>
      <button id="menu-btn" class="btn">MAIN MENU</button>
    </div>
  </div>

<script>
/* =========================
   CONFIG / STATE
   ========================= */
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');

// Responsive canvas sizing
function updateCanvasSize() {
  const container = document.getElementById('game-container');
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
}
updateCanvasSize();
window.addEventListener('resize', updateCanvasSize);

// Mobile touch handling
let isTouching = false;
let assetsLoaded = 0;
const totalAssets = 7;

// Screen management
const screens = {
  loading: document.getElementById('loading-screen'),
  preGame: document.getElementById('pre-game-loading-screen'),
  start: document.getElementById('start-screen'),
  leaderboard: document.getElementById('leaderboard-screen'),
  difficulty: document.getElementById('difficulty-screen'),
  gameOver: document.getElementById('game-over-screen')
};

function showScreen(screenName) {
  Object.values(screens).forEach(screen => screen.classList.add('hidden'));
  if (screens[screenName]) screens[screenName].classList.remove('hidden');
  
  const scoreEl = document.getElementById('score');
  scoreEl.style.display = (screenName === 'game') ? 'block' : 'none';
}

// Get UI elements
const playBtn = document.getElementById('play-btn');
const leaderboardBtn = document.getElementById('leaderboard-btn');
const exitBtn = document.getElementById('exit-btn');
const backBtn = document.getElementById('back-btn');
const easyBtn = document.getElementById('easy-btn');
const backDifficultyBtn = document.getElementById('back-difficulty-btn');
const restartBtn = document.getElementById('restart-btn');
const menuBtn = document.getElementById('menu-btn');
const scoreDisplay = document.getElementById('score');
const finalScoreDisplay = document.getElementById('final-score');
const highscoreSpan = document.getElementById('player-highscore');
const finalHighscoreSpan = document.getElementById('final-highscore');
const soundBtn = document.getElementById('sound-btn');
const modiImage = document.getElementById('modi-image');
const loadingBar = document.getElementById('loading-bar');
const loadingBirdEnd = document.getElementById('loading-bird-end');

// Load assets
const gameBackgroundImage = new Image();
gameBackgroundImage.src = "background.jpeg";
const startBackgroundImage = new Image();
startBackgroundImage.src = "modi2.jpeg";
const preGameBackgroundImage = new Image();
preGameBackgroundImage.src = "modi2.png";
const birdImage = new Image();
birdImage.src = "head.png";
const coinImage = new Image();
coinImage.src = "coin.png";
const obstacleImage = new Image();
obstacleImage.src = "obstacle.jpg";

function assetLoaded() {
  assetsLoaded++;
  if (assetsLoaded >= totalAssets) {
    setTimeout(() => {
      showScreen('start');
      startScreenLoop();
      initAudio();
    }, 800);
  }
}

[gameBackgroundImage, startBackgroundImage, preGameBackgroundImage, birdImage, coinImage, obstacleImage, modiImage].forEach(img => {
  img.onload = assetLoaded;
  img.onerror = assetLoaded;
});

/* PHYSICS CONFIGURATION */
const AIR_RESISTANCE = 0.98; // Air resistance slows horizontal movement
const GRAVITY = 0.12; // Very gentle gravity
const JUMP_FORCE = -3.2; // Stronger initial jump with momentum
const MAX_FALL_SPEED = 4; // Cap falling speed for slow descent
const FLAP_DURATION = 8; // Frames of upward momentum after flap

const GAME_SPEED = 1.0; // Base speed multiplier
const PIPE_SPEED = 1.1 * GAME_SPEED; // Slower obstacle speed
const PIPE_GAP = 230;
const PIPE_WIDTH = 65;
const BIRD_SIZE = 36;
const MIN_PIPE_HEIGHT = 55;
const MAX_PIPE_HEIGHT = canvas.height - 85 - PIPE_GAP - 55;
const COIN_SIZE = 30;
const PIPE_SPAWN_INTERVAL = 130; // Slower pipe spawning
const GRACE_PERIOD_DURATION = 2800; // Extended grace period

// Game state
let bird = { 
  x: 90, 
  y: canvas.height/2, 
  velocityY: 0, 
  velocityX: 0,
  radius: BIRD_SIZE/2,
  flapTimer: 0
};
let pipes = [];
let coins = [];
let clouds = [];
let frames = 0;
let score = 0;
let highscore = 0;
let gameRunning = false;
let gameStarted = false;
let soundsEnabled = true;
let gracePeriod = false;
let gracePeriodTimer = null;
let pipeCountSinceLastCoin = 0;
let isCollecting = false;
let preGameLoadingInterval = null;
let gameLoopId = null;

// Initialize clouds
for (let i = 0; i < 4; i++) {
  clouds.push({ 
    x: Math.random() * canvas.width, 
    y: Math.random() * 180, 
    w: 35 + Math.random() * 45, 
    h: 18 + Math.random() * 18, 
    s: 0.15 + Math.random() * 0.25 
  });
}

// Load highscore
try {
  const saved = localStorage.getItem('flappyBirdHighscore');
  if (saved !== null) highscore = parseInt(saved, 10) || 0;
} catch(e) { highscore = 0; }
highscoreSpan.textContent = highscore;
finalHighscoreSpan.textContent = highscore;

/* =========================
   AUDIO SYSTEM
   ========================= */
let audioContext, bgMusic, flapSound, pointSound, deathSound, collectSound, buttonSound;
let audioInitialized = false;

function initAudio() {
  if (audioInitialized) return;
  audioInitialized = true;
  
  try {
    // Create audio context for better control
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // Create gain nodes for volume control
    const mainGain = audioContext.createGain();
    mainGain.connect(audioContext.destination);
    mainGain.gain.value = soundsEnabled ? 1 : 0;
    
    // Background music
    bgMusic = new Audio("bg.mp3");
    bgMusic.loop = true;
    bgMusic.volume = 0.5;
    
    // Sound effects
    deathSound = new Audio("death.mp3");
    collectSound = new Audio("collect.mp3");
    buttonSound = new Audio("anime-ahh.mp3");
    
    // Create flap sound programmatically
    flapSound = createTone(800, 0.15);
    pointSound = createTone(1200, 0.12);
    
  } catch(e) {
    console.log('Audio init error:', e);
    soundsEnabled = false;
  }
}

function createTone(frequency, duration) {
  if (!audioContext) return null;
  
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  
  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  
  oscillator.frequency.value = frequency;
  oscillator.type = 'sine';
  gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
  gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
  
  oscillator.start();
  oscillator.stop(audioContext.currentTime + duration);
  
  return { play: () => {
    if (soundsEnabled && audioContext) {
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc.connect(gain);
      gain.connect(audioContext.destination);
      osc.frequency.value = frequency;
      osc.type = 'sine';
      gain.gain.setValueAtTime(0.2, audioContext.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
      osc.start();
      osc.stop(audioContext.currentTime + duration);
    }
  }};
}

function playSound(sound) {
  if (!soundsEnabled || !sound) return;
  if (typeof sound.play === 'function') sound.play();
}

/* =========================
   GAME MECHANICS
   ========================= */
function startPreGameLoading() {
  showScreen('preGame');
  drawPreGameBackground();
  
  let progress = 0;
  const totalDuration = 7000;
  const startTime = Date.now();
  
  if (preGameLoadingInterval) clearInterval(preGameLoadingInterval);
  
  preGameLoadingInterval = setInterval(() => {
    const elapsed = Date.now() - startTime;
    const percentage = Math.min((elapsed / totalDuration) * 100, 100);
    progress = percentage;
    
    loadingBar.style.width = progress + '%';
    loadingBirdEnd.style.transform = `translateX(${(progress/100) * loadingBar.parentElement.clientWidth - 15}px)`;
    
    if (progress >= 100) {
      clearInterval(preGameLoadingInterval);
      startActualGame();
    }
  }, 40);
}

function drawPreGameBackground() {
  if (preGameBackgroundImage.complete && preGameBackgroundImage.naturalWidth > 0) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.filter = 'brightness(0.85)';
    ctx.drawImage(preGameBackgroundImage, 0, 0, canvas.width, canvas.height);
    ctx.filter = 'none';
  }
}

function startActualGame() {
  showScreen('game');
  resetGame();
  gameRunning = true;
  gameStarted = true;
  if (soundsEnabled && bgMusic) {
    bgMusic.play().catch(() => {});
  }
  gameLoop();
}

function resetGame() {
  bird = { x:90, y:canvas.height/2, velocityY:0, velocityX:0, radius:BIRD_SIZE/2, flapTimer:0 };
  pipes = []; coins = []; frames = 0; score = 0; pipeCountSinceLastCoin = 0;
  scoreDisplay.textContent = '0';
  modiImage.style.display = 'none';
  gracePeriod = true;
  
  if (gracePeriodTimer) clearTimeout(gracePeriodTimer);
  gracePeriodTimer = setTimeout(() => gracePeriod = false, GRACE_PERIOD_DURATION);
}

/* =========================
   PHYSICS & RENDERING
   ========================= */
function updateBird() {
  // Handle flap momentum
  if (bird.flapTimer > 0) {
    bird.flapTimer--;
    bird.velocityY = JUMP_FORCE;
  }
  
  // Apply gravity (only outside grace period)
  if (!gracePeriod) {
    bird.velocityY += GRAVITY;
    
    // Apply air resistance
    bird.velocityY *= AIR_RESISTANCE;
    
    // Cap falling speed for slow descent
    if (bird.velocityY > MAX_FALL_SPEED) {
      bird.velocityY = MAX_FALL_SPEED;
    }
    
    bird.y += bird.velocityY;
  }
  
  // Boundary checks
  if (bird.y - bird.radius < 0) {
    bird.y = bird.radius;
    bird.velocityY = 0;
  }
  if (bird.y + bird.radius > canvas.height - 80) {
    triggerGameOver();
  }
}

function flap() {
  if (!gameStarted || !gameRunning) return;
  bird.flapTimer = FLAP_DURATION; // Apply upward momentum for several frames
  playSound(flapSound);
}

function updatePipes() {
  if (!gracePeriod && frames % PIPE_SPAWN_INTERVAL === 0) createPipe();
  
  for (let i = pipes.length - 1; i >= 0; i--) {
    const p = pipes[i];
    p.x -= PIPE_SPEED;
    
    // Advanced pipe behaviors
    if (p.behavior) {
      if (p.behavior.type === 1) { // Wobble
        p.wobbleOffset = Math.sin(p.behavior.wobblePhase) * p.behavior.wobbleAmplitude;
        p.behavior.wobblePhase += p.behavior.wobbleFrequency;
      } else if (p.behavior.type === 2) { // Drift
        p.driftOffset = Math.sin(frames * p.behavior.driftSpeed) * p.behavior.driftAmplitude * p.behavior.driftDirection;
      }
    }
    
    if (!p.passed && p.x + PIPE_WIDTH < bird.x) {
      p.passed = true;
      score++;
      scoreDisplay.textContent = score;
      playSound(pointSound);
    }
    
    if (p.x + PIPE_WIDTH < 0) pipes.splice(i, 1);
  }
}

function createPipe() {
  const topH = Math.floor(MIN_PIPE_HEIGHT + Math.random() * (MAX_PIPE_HEIGHT - MIN_PIPE_HEIGHT));
  const behaviorType = Math.random() < 0.3 ? Math.floor(Math.random() * 3) : 0;
  
  let behavior = null;
  if (behaviorType > 0) {
    behavior = { type: behaviorType };
    if (behaviorType === 1) {
      behavior.wobblePhase = Math.random() * Math.PI * 2;
      behavior.wobbleAmplitude = 2 + Math.random() * 3;
      behavior.wobbleFrequency = 0.015 + Math.random() * 0.025;
    } else if (behaviorType === 2) {
      behavior.driftDirection = Math.random() > 0.5 ? 1 : -1;
      behavior.driftSpeed = 0.04 + Math.random() * 0.08;
      behavior.driftAmplitude = 12 + Math.random() * 18;
    }
  }
  
  pipes.push({ 
    x: canvas.width, 
    topHeight: topH, 
    passed: false, 
    behavior: behavior
  });
  
  pipeCountSinceLastCoin++;
  if (pipeCountSinceLastCoin >= 6 + Math.floor(Math.random() * 4)) {
    coins.push({ 
      x: canvas.width + 120,
      y: topH + Math.random() * (PIPE_GAP - COIN_SIZE),
      collected: false
    });
    pipeCountSinceLastCoin = 0;
  }
}

function drawBird() {
  ctx.shadowColor = 'rgba(0,0,0,0.15)';
  ctx.shadowBlur = 8;
  ctx.shadowOffsetX = 1;
  ctx.shadowOffsetY = 2;
  
  if (birdImage.complete && birdImage.naturalWidth > 0) {
    // Apply slight rotation based on velocity for realism
    const rotation = Math.min(Math.max(bird.velocityY * 0.05, -0.3), 0.3);
    ctx.save();
    ctx.translate(bird.x, bird.y);
    ctx.rotate(rotation);
    ctx.drawImage(birdImage, -BIRD_SIZE/2, -BIRD_SIZE/2, BIRD_SIZE, BIRD_SIZE);
    ctx.restore();
  } else {
    ctx.fillStyle = '#3498db';
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, bird.radius, 0, Math.PI * 2);
    ctx.fill();
  }
  
  ctx.shadowColor = 'transparent';
  ctx.shadowBlur = 0;
}

function drawPipes() {
  pipes.forEach(pipe => {
    ctx.shadowColor = 'rgba(0,0,0,0.1)';
    ctx.shadowBlur = 6;
    
    const drawPipePart = (x, y, width, height, isTop) => {
      if (obstacleImage.complete && obstacleImage.naturalWidth > 0) {
        ctx.drawImage(obstacleImage, x, y, width, height);
        ctx.strokeStyle = '#27ae60';
        ctx.lineWidth = 1.5;
        ctx.strokeRect(x, y, width, height);
      } else {
        ctx.fillStyle = isTop ? '#27ae60' : '#2ecc71';
        ctx.fillRect(x, y, width, height);
        ctx.strokeStyle = '#1d8e4e';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, width, height);
      }
    };
    
    // Apply offsets from behaviors
    const offsetX = (pipe.wobbleOffset || 0) + (pipe.driftOffset || 0);
    const renderX = pipe.x + offsetX;
    
    drawPipePart(renderX, 0, PIPE_WIDTH, pipe.topHeight, true);
    drawPipePart(renderX, pipe.topHeight + PIPE_GAP, PIPE_WIDTH, canvas.height - (pipe.topHeight + PIPE_GAP), false);
    
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
  });
}

function drawClouds() {
  ctx.fillStyle = 'rgba(255,255,255,0.85)';
  clouds.forEach(c => {
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.w * 0.3, 0, Math.PI * 2);
    ctx.arc(c.x + c.w * 0.3, c.y - c.h * 0.2, c.w * 0.25, 0, Math.PI * 2);
    ctx.arc(c.x + c.w * 0.6, c.y, c.w * 0.35, 0, Math.PI * 2);
    ctx.fill();
  });
}

function updateClouds() {
  clouds.forEach(c => {
    c.x -= c.s;
    if (c.x + c.w < 0) {
      c.x = canvas.width + 20;
      c.y = Math.random() * 160;
    }
  });
}

function drawBackground() {
  if (gameBackgroundImage.complete && gameBackgroundImage.naturalWidth > 0) {
    ctx.filter = 'brightness(0.9)';
    ctx.drawImage(gameBackgroundImage, 0, 0, canvas.width, canvas.height);
    ctx.filter = 'none';
  } else {
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#74b9ff');
    gradient.addColorStop(1, '#0984e3');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
}

function drawGround() {
  ctx.fillStyle = '#dfe6e9';
  ctx.fillRect(0, canvas.height - 80, canvas.width, 80);
  ctx.fillStyle = '#636e72';
  ctx.fillRect(0, canvas.height - 80, canvas.width, 2);
  for(let i = 0; i < canvas.width; i += 25) {
    ctx.fillStyle = '#b2bec3';
    ctx.fillRect(i, canvas.height - 70, 12, 3);
  }
}

/* =========================
   GAME LOOP
   ========================= */
function gameLoop() {
  frames++;
  
  drawBackground();
  
  if (gameRunning) {
    updateClouds(); drawClouds();
    updatePipes(); drawPipes();
    updateBird(); drawBird();
    drawGround();
    
    // Simple collision detection
    for (let i = 0; i < pipes.length; i++) {
      const p = pipes[i];
      const offsetX = (p.wobbleOffset || 0) + (p.driftOffset || 0);
      const pipeLeft = p.x + offsetX;
      const pipeRight = pipeLeft + PIPE_WIDTH;
      
      if (bird.x + bird.radius > pipeLeft && bird.x - bird.radius < pipeRight) {
        if (bird.y - bird.radius < p.topHeight || bird.y + bird.radius > p.topHeight + PIPE_GAP) {
          triggerGameOver();
          break;
        }
      }
    }
  } else {
    updateClouds(); drawClouds();
    drawPipes(); drawBird();
    drawGround();
  }
  
  gameLoopId = requestAnimationFrame(gameLoop);
}

function startScreenLoop() {
  if (!screens.start.classList.contains('hidden')) {
    drawStartScreenBackground();
    requestAnimationFrame(startScreenLoop);
  }
}

function drawStartScreenBackground() {
  if (startBackgroundImage.complete && startBackgroundImage.naturalWidth > 0) {
    ctx.filter = 'brightness(0.95) blur(1px)';
    ctx.drawImage(startBackgroundImage, 0, 0, canvas.width, canvas.height);
    ctx.filter = 'none';
  } else {
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
}

/* =========================
   GAME CONTROL
   ========================= */
function triggerGameOver() {
  if (!gameRunning) return;
  gameRunning = false;
  if (gameLoopId) cancelAnimationFrame(gameLoopId);
  
  if (soundsEnabled && bgMusic) {
    bgMusic.pause();
    bgMusic.currentTime = 0;
  }
  
  modiImage.style.display = 'block';
  setTimeout(() => modiImage.style.display = 'none', 1500);
  
  finalScoreDisplay.textContent = score;
  if (score > highscore) {
    highscore = score;
    try { localStorage.setItem('flappyBirdHighscore', highscore.toString()); } catch(e) {}
  }
  highscoreSpan.textContent = highscore;
  finalHighscoreSpan.textContent = highscore;
  showScreen('gameOver');
}

/* =========================
   EVENT HANDLERS
   ========================= */
// UI Navigation
playBtn.onclick = () => { playSound(buttonSound); showScreen('difficulty'); };
leaderboardBtn.onclick = () => { playSound(buttonSound); showScreen('leaderboard'); };
exitBtn.onclick = () => { playSound(buttonSound); window.open("https://www.youtube.com/embed/xvFZjo5PgG0?autoplay=1", "_blank"); };
backBtn.onclick = () => { playSound(buttonSound); showScreen('start'); };
easyBtn.onclick = () => { playSound(buttonSound); startPreGameLoading(); };
backDifficultyBtn.onclick = () => { playSound(buttonSound); showScreen('start'); };
restartBtn.onclick = () => { playSound(buttonSound); initAudio(); resetGame(); showScreen('game'); gameRunning = true; if (soundsEnabled && bgMusic) bgMusic.play().catch(() => {}); gameLoop(); };
menuBtn.onclick = () => { playSound(buttonSound); showScreen('start'); gameRunning = false; if (soundsEnabled && bgMusic) { bgMusic.pause(); bgMusic.currentTime = 0; } };

// Sound toggle
soundBtn.onclick = () => {
  soundsEnabled = !soundsEnabled;
  soundBtn.textContent = soundsEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
  if (audioContext) {
    // This would control audio context gain in a full implementation
  }
};

// Input handling
function handleTouchStart(e) { e.preventDefault(); if (!isTouching) { isTouching = true; flap(); } }
function handleTouchEnd(e) { e.preventDefault(); isTouching = false; }

document.body.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
canvas.addEventListener('click', e => { if (!isTouching) flap(); });
['touchstart', 'touchend', 'touchcancel'].forEach(event => 
  canvas.addEventListener(event, event === 'touchstart' ? handleTouchStart : handleTouchEnd, { passive: false })
);
document.addEventListener('keydown', e => { if (e.code === 'Space') { e.preventDefault(); flap(); } });

// Prevent zooming
['gesturestart', 'gesturechange', 'gestureend'].forEach(event => 
  document.addEventListener(event, e => e.preventDefault())
);

// Initialize
window.addEventListener('load', updateCanvasSize);
</script>
</body>
</html>

